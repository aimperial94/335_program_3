Given:
	coordinate struct -- p
	int array -- bestSet A
	int -- i, n
	float -- bestDist, Dist

Psuedo Code:

1:  Dist = farthest(n,P);

1:	  float max_dist = 0
2:	  int i, j
1:	  float dist
	  
n-1:	  for i 0 to n-2 
n:	    for j to n-1 
1:	      dist = abs(P[i].x - P[j].x) + abs(P[i].y - P[j].y)
1:	      if max_dist < dist
1:	    	max_dist = dist;

1:	  return max_dist;

  bestDist = n*Dist;
  
  // populate the starting array for the permutation algorithm
  A = new int[n];
  // populate the array A with the values in the range 0 .. n-1
  for(i=0; i<n; i++)
    A[i] = i;
  
  // calculate the Hamiltonian cycle of minimum weight
  print_perm(n, A, n, P, bestSet, bestDist);
 
	  int i;
	  float dist = 0;
	  
	  if (n == 1) 
	  {
	    // we obtain a permutation so we compare it against the current shortest
	    // Hamiltonian cycle
	    // YOU NEED TO COMPLETE THIS PART
	    int j = 1;
	    for(int i = 0; i < sizeA; ++i, ++j)
	    {
		    if(j == sizeA)
			    j = 0;

		    dist += abs(P[A[i]].x - P[A[j]].x) + abs(P[A[i]].y - P[A[j]].y);
		    
	    }
	    if(dist < bestDist)
	    {
		for(int i = 0; i < sizeA; ++i)
		{
			bestDist = dist;
			bestSet[i] = A[i];
		}
	    }
	  }
	  else 
	  {
	    for(i = 0 ; i< n-1; i++) 
	    {
	      print_perm(n - 1, A, sizeA, P, bestSet, bestDist);
	      if (n%2 == 0)
	      {
	      // swap(A[i], A[n-1])
	      int temp = A[i];
	      A[i] = A[n-1];
	      A[n-1]=temp;
	      }
	      else
	      {
	      // swap(A[0], A[n-1])
	      int temp = A[0];
	      A[0] = A[n-1];
	      A[n-1]=temp;
	      }
	    }
	    print_perm(n - 1, A, sizeA, P, bestSet, bestDist);
	  }

